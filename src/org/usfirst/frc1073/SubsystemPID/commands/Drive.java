// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1073.SubsystemPID.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1073.SubsystemPID.Robot;

/**
 *
 */
public class  Drive extends Command implements PIDCommand{
	private double deadZone;
	private double setpointFL;
	private double setpointFR;
	private double setpointBL;
	private double setpointBR;
	final double scaler = 1 / .707;
	
	private boolean isPID;
	
    public Drive() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        deadZone = 0.05;
        isPID = true;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	//get the joystick values for mecanum drive
    	double twist = Robot.oi.getdriver().getRawAxis(5);
		double mag = Robot.oi.getdriver().getMagnitude();
		double joyAngle = Robot.oi.getdriver().getDirectionDegrees();
		double joyScale = Robot.oi.getdriver().getZ();
		//deadzone adjust
		if (Math.abs(mag) < deadZone) {
			mag = 0;
		}
		twist = twist / 2;
		if (Math.abs(twist) < deadZone) {
			twist = 0;
		}
		
		joyScale = ((joyScale * -1) + 1) / 2;
		
		if(Math.abs(joyScale) < .1){
			joyScale = 0;
		}
		//System.out.println("JoyScale: " + joyScale);
		SmartDashboard.putNumber("Joystick Scale: ", joyScale);
		SmartDashboard.putBoolean("is PID Enabled? :", isPID);
		mag = mag * joyScale;
		twist = twist * joyScale;
		//mecanum joystick deflection
		joyAngle = ((joyAngle + 45) * 3.14159) / 180;
		double sinAngle = Math.sin(joyAngle);
		double cosAngle = Math.cos(joyAngle);
		//mecanum wheel deflection (creates PID setpoints)
		double drivePointFL = (sinAngle * mag + twist) * scaler;
		double drivePointFR = (cosAngle * mag - twist) * scaler;
		double drivePointBL = (cosAngle * mag + twist) * scaler;
		double drivePointBR = (sinAngle * mag - twist) * scaler;
		//normalize output (prevents > 1.0 setpoints)
		double[] drivePoints = normalize(drivePointFL, drivePointFR,
				drivePointBL, drivePointBR);
		//move back to setpoint variables from array
		drivePointFL = -1 * drivePoints[0];
		drivePointFR = drivePoints[1];
		drivePointBL = -1 * drivePoints[2];
		drivePointBR = drivePoints[3];
		
		if(isPID){
			Robot.driveTrain.enablePIDDrivetrainParameter();
			Robot.encoderSystem.enablePIDEncoderParameter();
			
			setpointFL = drivePointFL;
			setpointFR = drivePointFR;
			setpointBL = drivePointBL;
			setpointBR = drivePointBR;
		}
		else{
			Robot.driveTrain.disablePIDDrivetrainParameter();
			Robot.encoderSystem.disablePIDEncoderParameter();
			
			Robot.driveTrain.setFrontLeftSpeed(drivePointFL);
			Robot.driveTrain.setFrontRightSpeed(drivePointFR);
			Robot.driveTrain.setBackLeftSpeed(drivePointBL);
			Robot.driveTrain.setBackRightSpeed(drivePointBR);
			
			setpointFL = 0;
			setpointFR = 0;
			setpointBL = 0;
			setpointBR = 0;
		}
		
		/*
		System.out.println("Front Left Setpoint: " + setpointFL);
		System.out.println("Front Right Setpoint: " + setpointFR);
		System.out.println("Back Left Setpoint: " + setpointBL);
		System.out.println("Back Right Setpoint: " + setpointBR);
		*/
		/*
		System.out.println("Front left speed: " + Robot.encoderSystem.getFrontLeftSpeed());
		System.out.println("Front Right speed: " + Robot.encoderSystem.getFrontRightSpeed());
		System.out.println("Back left speed: " + Robot.encoderSystem.getBackLeftSpeed());
		System.out.println("Back Right speed: " + Robot.encoderSystem.getBackRightSpeed());
		*/
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
    private double[] normalize(double FL, double FR, double BL, double BR) {
		double[] setpoints = { FL, FR, BL, BR };
		double max = Math.abs(setpoints[0]);
		for (int i = 1; i < 4; i++) {
			double speed = Math.abs(setpoints[i]);
			if (speed > max) {
				max = speed;
			}
		}
		if (max > 1.0) {
			for (int i = 0; i < 4; i++) {
				setpoints[i] = (setpoints[i] / max);
			}
		}
		return setpoints;
	}

	@Override
	public double getPIDSetpoint(int marker) {
		switch (marker){
		case 0:
			return setpointFL;
		case 1:
			return setpointFR;
		case 2:
			return setpointBL;
		case 3:
			return setpointBR;
		default:
			return 0;
		}
	}
	
	public void switchDriveMode(){
		isPID = !isPID;
	}

	@Override
	public boolean isPIDEnabled() {
		return isPID;
	}
}
