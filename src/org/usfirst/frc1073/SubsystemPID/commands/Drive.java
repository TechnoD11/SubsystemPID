// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1073.SubsystemPID.commands;

import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc1073.SubsystemPID.Robot;

/**
 *
 */
public class  Drive extends Command implements PIDCommand{
	private double deadZone;
	private double setpointFL;
	private double setpointFR;
	private double setpointBL;
	private double setpointBR;
	final double scaler = 1 / .707;
	
    public Drive() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        deadZone = 0.05;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	//get the joystick values for mecanum drive
    	double twist = Robot.oi.getdriver().getRawAxis(5);
		double mag = Robot.oi.getdriver().getMagnitude();
		double joyAngle = Robot.oi.getdriver().getDirectionDegrees();
		double joyScale = Robot.oi.getdriver().getZ();
		//deadzone adjust
		if (Math.abs(mag) < deadZone) {
			mag = 0;
		}
		twist = twist / 2;
		if (Math.abs(twist) < deadZone) {
			twist = 0;
		}
		if(Math.abs(joyScale) < .1){
			joyScale = 0;
		}
		mag = mag * joyScale;
		//TODO Needs Negative deflection!
		//mecanum joystick deflection
		joyAngle = ((joyAngle + 45) * 3.14159) / 180;
		double sinAngle = Math.sin(joyAngle);
		double cosAngle = Math.cos(joyAngle);
		//mecanum wheel deflection (creates PID setpoints)
		setpointFL = (sinAngle * mag + twist) * scaler;
		setpointFR = (cosAngle * mag - twist) * scaler;
		setpointBL = (cosAngle * mag + twist) * scaler;
		setpointBR = (sinAngle * mag - twist) * scaler;
		//normalize output (prevents > 1.0 setpoints)
		double[] setpoints = normalize(setpointFL, setpointFR,
				setpointBL, setpointBR);
		//move back to setpoint variables from array
		setpointFL = -1 * setpoints[0];
		setpointFR = setpoints[1];
		setpointBL = -1 * setpoints[2];
		setpointBR = setpoints[3];
		/*
		System.out.println("Front Left Setpoint: " + setpointFL);
		System.out.println("Front Right Setpoint: " + setpointFR);
		System.out.println("Back Left Setpoint: " + setpointBL);
		System.out.println("Back Right Setpoint: " + setpointBR);
		*/
		/*
		System.out.println("Front left speed: " + Robot.encoderSystem.getFrontLeftSpeed());
		System.out.println("Front Right speed: " + Robot.encoderSystem.getFrontRightSpeed());
		System.out.println("Back left speed: " + Robot.encoderSystem.getBackLeftSpeed());
		System.out.println("Back Right speed: " + Robot.encoderSystem.getBackRightSpeed());
		*/
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
    private double[] normalize(double FL, double FR, double BL, double BR) {
		double[] setpoints = { FL, FR, BL, BR };
		double max = Math.abs(setpoints[0]);
		for (int i = 1; i < 4; i++) {
			double speed = Math.abs(setpoints[i]);
			if (speed > max) {
				max = speed;
			}
		}
		if (max > 1.0) {
			for (int i = 0; i < 4; i++) {
				setpoints[i] = (setpoints[i] / max);
			}
		}
		return setpoints;
	}

	@Override
	public double getPIDSetpoint(int marker) {
		switch (marker){
		case 0:
			return setpointFL;
		case 1:
			return setpointFR;
		case 2:
			return setpointBL;
		case 3:
			return setpointBR;
		default:
			return 0;
		}
	}
}
